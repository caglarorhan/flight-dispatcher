import type { Profile } from './profile';
import type { DetectionResult } from './detector';
import type { ProjectAnswers } from './prompts';
import { formatDate } from './utils';

// ─── Generator ────────────────────────────────────────────────────────────────

export function generate(
  profile: Profile,
  detected: DetectionResult,
  answers: ProjectAnswers
): string {
  const sections: string[] = [];

  sections.push(buildHeader(detected.projectName));
  sections.push(buildAbout(answers.description));
  sections.push(buildDeveloperPreferences(profile));
  sections.push(buildTechStack(detected, profile));
  sections.push(buildProjectStructure(detected));

  const archSection = buildArchitectureRules(answers, detected);
  if (archSection) sections.push(archSection);

  sections.push(buildDeployment(answers, detected));

  const todoSection = buildTodos(answers);
  if (todoSection) sections.push(todoSection);

  sections.push(buildKnownConventions(detected, answers));

  return sections.filter(Boolean).join('\n\n') + '\n';
}

// ─── Section Builders ─────────────────────────────────────────────────────────

function buildHeader(projectName: string): string {
  const date = formatDate();
  return [
    `# Copilot Instructions — ${projectName}`,
    '',
    `> Auto-generated by flight-dispatcher on ${date}. Re-run \`npx flight-dispatcher\` to update.`,
  ].join('\n');
}

function buildAbout(description: string): string {
  if (!description) return '';
  return ['## About This Project', '', description].join('\n');
}

function buildDeveloperPreferences(profile: Profile): string {
  const lines: string[] = ['## Developer Preferences', ''];

  // Language
  lines.push(`- **Language:** ${profile.languagePreference}${profile.languagePreference === 'TypeScript' ? ' (strict mode)' : ''}`);

  // Formatting
  const indent =
    profile.codeStyle.indentation === 'tabs'
      ? 'tabs'
      : profile.codeStyle.indentation === '2spaces'
      ? '2-space indent'
      : '4-space indent';
  const quotes = profile.codeStyle.quotes === 'single' ? 'single quotes' : 'double quotes';
  const semis = profile.codeStyle.semicolons ? 'semicolons' : 'no semicolons';
  lines.push(`- **Formatting:** ${quotes}, ${semis}, ${indent}`);

  // Commits
  const commitDisplay =
    profile.commitStyle === 'conventional'
      ? 'Conventional commits (feat:, fix:, chore:...)'
      : 'Freeform commit messages';
  lines.push(`- **Commits:** ${commitDisplay}`);

  // Verbosity
  lines.push(
    `- **Response style:** ${
      profile.verbosity === 'concise'
        ? 'Concise — focus on code, minimal explanation unless asked'
        : 'Detailed — explain reasoning and patterns'
    }`
  );

  // Comment style
  if (profile.commentStyle) {
    lines.push(`- **Comments:** ${profile.commentStyle}`);
  }

  // Test framework
  if (profile.testFramework) {
    lines.push(`- **Tests:** ${profile.testFramework}`);
  }

  // Custom rules
  for (const rule of profile.customRules) {
    lines.push(`- ${rule}`);
  }

  return lines.join('\n');
}

function buildTechStack(detected: DetectionResult, profile: Profile): string {
  const lines: string[] = ['## Tech Stack', ''];

  // Language + TS
  let languageLine = `- **Language:** ${detected.primaryLanguage}`;
  if (detected.hasTypeScript && detected.tsStrictMode) languageLine += ' (strict mode)';
  if (detected.nodeVersion) languageLine += `, Node ${detected.nodeVersion}`;
  lines.push(languageLine);

  // Package manager
  if (detected.packageManager) {
    lines.push(`- **Package manager:** ${detected.packageManager}`);
  }

  // Frontend frameworks
  const frontendItems: string[] = [
    ...detected.frameworks,
    ...detected.uiLibraries,
  ].filter(Boolean);
  if (detected.hasNextJs) {
    const router = detected.nextRouter
      ? ` (${detected.nextRouter === 'app' ? 'App Router' : detected.nextRouter === 'pages' ? 'Pages Router' : 'App + Pages Router'})`
      : '';
    const nextLabel = `Next.js${detected.nextVersion ? ' ' + detected.nextVersion : ''}${router}`;
    // Avoid double-listing if already in frameworks
    const dedupedFrontend = frontendItems.filter(
      (f) => !f.toLowerCase().startsWith('next.js')
    );
    lines.push(
      `- **Frontend:** ${[nextLabel, ...dedupedFrontend].join(', ')}`
    );
  } else if (frontendItems.length > 0) {
    lines.push(`- **Frontend:** ${frontendItems.join(', ')}`);
  }

  // Styling
  const stylingItems: string[] = [];
  if (detected.hasTailwind) stylingItems.push('TailwindCSS');
  if (detected.uiLibraries.length > 0) {
    for (const lib of detected.uiLibraries) {
      if (!lib.toLowerCase().includes('react')) stylingItems.push(lib);
    }
  }
  if (stylingItems.length > 0 && detected.hasNextJs) {
    lines.push(`- **Styling:** ${stylingItems.join(', ')}`);
  }

  // Backend
  if (detected.backendFrameworks.length > 0) {
    lines.push(`- **Backend:** ${detected.backendFrameworks.join(', ')}`);
  }

  // Database / ORM
  if (detected.hasPrisma) {
    const dbInfo = detected.prismaDbProvider
      ? capitalize(detected.prismaDbProvider) + ' via Prisma ORM'
      : 'Prisma ORM';
    lines.push(`- **Database:** ${dbInfo}`);
    if (detected.prismaModels.length > 0) {
      lines.push(`  - Models: \`${detected.prismaModels.join('`, `')}\``);
    }
  } else if (detected.hasDrizzle) {
    const dbInfo = detected.databaseType
      ? `${detected.databaseType} via Drizzle ORM`
      : 'Drizzle ORM';
    lines.push(`- **Database:** ${dbInfo}`);
  } else if (detected.databaseType) {
    lines.push(`- **Database:** ${detected.databaseType}`);
  }

  // Auth
  if (detected.authType) {
    lines.push(`- **Auth:** ${detected.authType}`);
  }

  // i18n
  if (detected.hasI18n) {
    const localeInfo =
      detected.i18nLocales.length > 0
        ? `, ${detected.i18nLocales.length} locales (${detected.i18nLocales.join(', ')})`
        : '';
    const defaultLocaleInfo = detected.i18nDefaultLocale
      ? `, default: ${detected.i18nDefaultLocale}`
      : '';
    lines.push(`- **i18n:** ${detected.libraries.includes('next-intl') ? 'next-intl' : 'i18n'}${localeInfo}${defaultLocaleInfo}`);
  }

  // State management
  if (detected.stateManagement.length > 0) {
    lines.push(`- **State:** ${detected.stateManagement.join(', ')}`);
  }

  // Testing
  if (detected.testRunner || profile.testFramework) {
    lines.push(`- **Tests:** ${detected.testRunner ?? profile.testFramework}`);
  }

  // Build
  if (detected.buildTool) {
    lines.push(`- **Build:** ${detected.buildTool}`);
  }

  // Docker services
  if (detected.dockerServices.length > 0) {
    lines.push(`- **Services (Docker):** ${detected.dockerServices.join(', ')}`);
  }

  // Notable libraries
  const notableLibs = detected.libraries.filter(
    (lib) =>
      !['next-intl', 'i18next', 'Redis client'].includes(lib) &&
      lib !== 'Redis'
  );
  if (notableLibs.length > 0) {
    lines.push(`- **Libraries:** ${notableLibs.join(', ')}`);
  }

  // CI/CD
  if (detected.ciPlatforms.length > 0) {
    lines.push(`- **CI/CD:** ${detected.ciPlatforms.join(', ')}`);
  }

  // Python stack
  if (detected.pythonStack.length > 0) {
    lines.push(`- **Python stack:** ${detected.pythonStack.join(', ')}`);
  }

  // PHP stack
  if (detected.phpStack.length > 0) {
    lines.push(`- **PHP stack:** ${detected.phpStack.join(', ')}`);
  }

  // Go modules
  if (detected.goModules.length > 0) {
    lines.push(`- **Go modules:** ${detected.goModules.slice(0, 5).join(', ')}`);
  }

  // Env vars
  if (detected.envVars.length > 0) {
    lines.push('');
    lines.push('### Environment Variables');
    for (const envVar of detected.envVars) {
      lines.push(`- \`${envVar}\``);
    }
  }

  return lines.join('\n');
}

function buildProjectStructure(detected: DetectionResult): string {
  if (detected.projectStructure.length === 0) return '';

  const lines: string[] = ['## Project Structure', ''];
  for (const { path, description } of detected.projectStructure) {
    lines.push(`- \`${path}/\` — ${description}`);
  }

  // TypeScript path aliases
  if (detected.tsPathAliases.length > 0) {
    lines.push('');
    lines.push(`**Path aliases:** ${detected.tsPathAliases.join(', ')}`);
  }

  return lines.join('\n');
}

function buildArchitectureRules(
  answers: ProjectAnswers,
  detected: DetectionResult
): string {
  const rules: string[] = [...answers.architectureRules];

  // Auto-rules from detection
  if (answers.prismaSchemaCommand) {
    rules.push(
      `DB schema changes: \`${answers.prismaSchemaCommand}\` — never use \`prisma migrate dev\` in production`
    );
  }

  if (detected.hasI18n && detected.i18nLocales.length > 0) {
    rules.push(
      `i18n: add translation keys to ALL ${detected.i18nLocales.length} locale files when introducing new UI text`
    );
  }

  if (detected.nextRouter === 'app') {
    rules.push(
      "Client components require `'use client'` directive — metadata lives in `layout.tsx`, not `page.tsx`"
    );
  }

  if (answers.wantTests === false) {
    rules.push('Do not suggest tests unless explicitly asked');
  } else if (answers.wantTests === true) {
    rules.push('Always suggest tests for new functions and components');
  }

  if (rules.length === 0) return '';

  const lines: string[] = ['## Architecture Rules', ''];
  for (const rule of rules) {
    lines.push(`- ${rule}`);
  }
  return lines.join('\n');
}

function buildDeployment(answers: ProjectAnswers, detected: DetectionResult): string {
  const lines: string[] = ['## Deployment', ''];

  lines.push(`- **Target:** ${answers.deploymentTarget}`);

  if (detected.hasDockerCompose) {
    lines.push('- **Containerized:** Yes (docker-compose)');
  }

  if (detected.hasCI) {
    lines.push(`- **CI/CD:** ${detected.ciPlatforms.join(', ')}`);
  }

  if (answers.monorepoFocus) {
    lines.push(`- **Monorepo focus:** \`${answers.monorepoFocus}\``);
  }

  return lines.join('\n');
}

function buildTodos(answers: ProjectAnswers): string {
  if (answers.todos.length === 0) return '';

  const lines: string[] = ['## Pending TODOs', ''];
  for (const todo of answers.todos) {
    lines.push(`- [ ] ${todo}`);
  }
  return lines.join('\n');
}

function buildKnownConventions(
  detected: DetectionResult,
  answers: ProjectAnswers
): string {
  const conventions: string[] = [];

  // Prisma
  if (answers.prismaSchemaCommand) {
    conventions.push(
      `**DB schema changes:** \`${answers.prismaSchemaCommand}\``
    );
  }

  // Git
  if (detected.commitStyleDetected === 'conventional') {
    conventions.push('**Git commits:** Conventional format (`feat:`, `fix:`, `chore:`, `docs:`, etc.)');
  }

  // Tooling
  if (detected.hasBiome) {
    conventions.push('**Formatter/linter:** Biome (not ESLint/Prettier)');
  } else {
    const tools: string[] = [];
    if (detected.hasEslint) tools.push('ESLint');
    if (detected.hasPrettier) tools.push('Prettier');
    if (tools.length > 0) {
      conventions.push(`**Code quality:** ${tools.join(' + ')}`);
    }
  }

  // Prettier rules
  const pr = detected.prettierRules;
  if (Object.keys(pr).length > 0) {
    const ruleLines: string[] = [];
    if ('singleQuote' in pr) ruleLines.push(`singleQuote: ${pr['singleQuote']}`);
    if ('semi' in pr) ruleLines.push(`semi: ${pr['semi']}`);
    if ('tabWidth' in pr) ruleLines.push(`tabWidth: ${pr['tabWidth']}`);
    if ('printWidth' in pr) ruleLines.push(`printWidth: ${pr['printWidth']}`);
    if (ruleLines.length > 0) {
      conventions.push(`**Prettier config:** ${ruleLines.join(', ')}`);
    }
  }

  if (conventions.length === 0) return '';

  const lines: string[] = ['## Known Conventions', ''];
  for (const conv of conventions) {
    lines.push(`- ${conv}`);
  }
  return lines.join('\n');
}

function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
